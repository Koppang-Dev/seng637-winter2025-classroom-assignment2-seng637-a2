**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group 23:      |     |
| -------------- | --- |
| Student Names: |     |
|Riley Koppang   |     |
|Yousef Fatouraee|     |
|                |     |


**Table of Contents**

1. [Introduction](#Introduction)  
2. [Detailed Description of Unit Test Strategy](#Detailed-description-of-unit-test-strategy)  
3. [Comparison of exploratory and manual functional testing](#comparison-of-exploratory-and-manual-functional-testing)  
4. [Notes and discussion of the peer reviews of defect reports](#notes-and-discussion-of-the-peer-reviews-of-defect-reports)  
5. [How the pair testing was managed and team work/effort was divided](#how-the-pair-testing-was-managed-and-team-workeffort-was-divided)  
6. [Difficulties encountered, challenges overcome, and lessons learned](#difficulties-encountered-challenges-overcome-and-lessons-learned)  
7. [Comments/feedback on the lab and lab document itself](#commentsfeedback-on-the-lab-and-lab-document-itself)

# 1 Introduction
This lab report outlines our test case design and our testing strategy for unit testing. We used Equivalence Partitioning and Boundary Analysis as our black-box testing techniques for this assignment. Additionally, we have described how we will test each function, how we partitioned it, and how we will combine boundary analysis. In the `Test Cases Developed` section, we explain each test we developed for the given functions in greater detail. 

# 2 Detailed description of unit test strategy
We attempted to use Equivalence Partitioning and Boundary Analysis for each of the tested functions. For Equivalence Partitioning the goal was the reduce redunancy by testing disjoint classes and esuring the entired input set is covered. For example, we would have a parition for invalid ranges and a partition for valid ranges. For Boundary Analysis, the following: Below Lower Bounday, Lower Boundary, Value Above Lower Boundary, Nominal Value, Below Upper Boundary, Upper Bounday and Above Upper Boundary. When we combine these approaches, for each indiviual test cases we can keep a sinlge nominal value, which would also inlcude the the Lower Boundary, Upper Boundary, Above Lower Boundary, Below Upper Boundary and Nominal Value. Therefore, in most situations we would be left with test cases covering a value below the lower boundary (invalid partition), a nominal value (a valid partition) and a Above Upper Boundary (a valid partition). Sometimes, testing both the Lower Boundary and Upper Boundary was more practical to ensure the boundary analysis was fully robust. The following chart will describe how we split up each class function and our objective and reasoning for each split. The section proceeding the chart will go into greater detail about each test for each function.


# 📊 Unit Test Cases Summary

## 1. Combine(Range range1, Range range2)**

| **Overview** | Creates a new range by combining two existing ranges. Either range can be `null`, and if both are `null`, the return value is `null`. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** |Both ranges are non-null <br> One range is null <br> Both ranges are null |
| **Boundary Analysis** | Test the lower and upper bounds <br> Test a nominal value|
| **Tests Completed** | Checked when both ranges are null <br> Checked when one range is null <br> Checked when both are valid |
---

## **2️⃣ Constrain(double value)**

| **Overview** | Returns the closest value within the range. If the value is within the range, it returns the input value. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Value is within the range <br> ❌ Value is outside the range |
| **Boundary Analysis** | ✅ Value inside range <br> ✅ Value outside range <br> ✅ Value at lower bound <br> ✅ Value at upper bound |
| **Tests Completed** | ☑ Value inside range <br> ☑ Value above range <br> ☑ Value below range |
| **Error** | 🚨 Returns the value right after the lower boundary. |

---

## **3️⃣ Intersects(double lower, double upper)**

| **Overview** | Returns `true` if the range intersects with the given range and `false` otherwise. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ `lower ≤ upper bound` <br> ✅ `upper ≥ lower bound` <br> ❌ `lower > upper bound` <br> ❌ `upper < lower bound` |
| **Boundary Analysis** | ✅ `Lower == lower boundary` <br> ✅ `Upper == upper boundary` <br> ❌ `Lower > upper` <br> ❌ `Upper < lower` |
| **Tests Completed** | ☑ Testing one overlapping range <br> ☑ Testing non-overlapping ranges <br> ☑ Testing when upper < lower (should throw an exception) <br> ☑ Testing when the given range is inside/outside the range |
| **Errors** | 🚨 Should return `false` but returns `true`. <br> 🚨 Should throw an exception when `upper < lower` but does not. |

---

## **4️⃣ getLength()**

| **Overview** | Returns the length of the range. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Valid range with positive length <br> ❌ Invalid range with negative length |
| **Boundary Analysis** | ✅ Length = 0 <br> ✅ Positive bounds <br> ✅ Negative bounds <br> ✅ Negative & positive bounds |
| **Tests Completed** | ☑ Tested all boundary conditions |

---

## **5️⃣ expandToInclude(Range range, double value)**

| **Overview** | Returns a range that includes all values in the given range and the specified value. The range can be `null`. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Negative value <br> ✅ Positive value <br> ✅ Value already included in the range |
| **Boundary Analysis** | ✅ Value at lower boundary <br> ✅ Value at upper boundary <br> ✅ Value outside range <br> ✅ `null` range with negative/positive value |
| **Tests Completed** | ☑ Value above upper bound <br> ☑ Value below lower bound <br> ☑ Value inside range |
| **Error** | 🚨 `getUpperBound` and `getLowerBound` are swapped, causing failures. |

---

## **6️⃣ calculateColumnTotal(Values2D data, int column)**

| **Overview** | Returns the sum of values in a column of a 2D data table. `data` cannot be `null`. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Valid 2D array & column index <br> ❌ `data` is `null` <br> ❌ Column index is negative <br> ❌ Column index ≥ number of columns |
| **Boundary Analysis** | ✅ Column at lower boundary (`0`) <br> ✅ Column at upper boundary (`N-1`) <br> ✅ Column out of range <br> ✅ Empty data table |
| **Tests Completed** | ☑ Valid array with valid column <br> ☑ `data` is `null` <br> ☑ Negative column index <br> ☑ Column index out of range |

---

## **7️⃣ calculateRowTotal(Values2D data, int row)**

| **Overview** | Returns the sum of values in a row of a 2D data table. `data` cannot be `null`. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Valid 2D array & row index <br> ❌ `data` is `null` <br> ❌ Row index is negative <br> ❌ Row index ≥ number of rows |
| **Boundary Analysis** | ✅ Row at lower boundary (`0`) <br> ✅ Row at upper boundary (`N-1`) <br> ✅ Row out of range <br> ✅ Empty data table |
| **Tests Completed** | ☑ Valid array with valid row <br> ☑ `data` is `null` <br> ☑ Negative row index <br> ☑ Row index out of range |
| **Errors** | 🚨 Does not return correct sum. <br> 🚨 Does not throw an exception for invalid indexes. |

---

## **8️⃣ createNumberArray(double[] data)**

| **Overview** | Converts an array of `double` values into an array of `Number` objects. `data` cannot be `null`. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Non-null data <br> ❌ Null data <br> ❌ Empty array |
| **Boundary Analysis** | ✅ Array with all `0`s <br> ✅ Single-element array <br> ✅ All positive values <br> ✅ All negative values <br> ✅ Mixed values |
| **Error** | 🚨 Returns `null` for the last element in arrays. |

---

## **9️⃣ createNumberArray2D(double[][] data)**

| **Overview** | Converts a 2D `double` array into a 2D array of `Number` objects. `data` cannot be `null`. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Non-null data <br> ❌ Null data <br> ❌ Empty array |
| **Boundary Analysis** | ✅ All `0`s <br> ✅ Single row, multiple columns <br> ✅ Multiple rows, one column <br> ✅ All positives <br> ✅ All negatives <br> ✅ Mixed values |
| **Error** | 🚨 Returns `null` for the last element of each row (due to `createNumberArray()`). |

---

## **🔟 getCumulativePercentages(KeyedValuesData)**

| **Overview** | Returns cumulative percentage values for data in a `KeyedValues` instance. |
|-------------|--------------------------------------------------|
| **Equivalence Partitioning** | ✅ Normal data <br> ✅ Single data point <br> ❌ Null data <br> ❌ Data contains negative values |
| **Boundary Analysis** | ✅ Single object <br> ✅ Large dataset <br> ❌ Negative values <br> ❌ Empty dataset |
| **Errors** | 🚨 Returns incorrect percentages. <br> 🚨 Returns `Infinity` for a single data point. <br> 🚨 Does not check for negative values, causing negative percentages. |

---

### **📌 Summary**
- ❌ **Major issues** in `Intersects()`, `calculateRowTotal()`, `createNumberArray()`, and `getCumulativePercentages()`.
- 🚨 Several methods **fail boundary cases** or **return incorrect values**.
- ✅ Tests identify edge cases effectively.

### Mocking Benefits and Drawbacks **

*** TO DO ADD THIS






# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

We designed the test cases together initially. Then Riley wrote the tests for the Range class, and Yousef wrote the more complex test cases for the DataUtilities class. When someone used a mocked object for one class, if that mock was also needed for other tested functions, they would write those functions. Since, in the end, Riley was struggling to run the project pulling from GitHub, he focused on the lab report while Yousef cleaned up the code and test cases.


# 5 Difficulties encountered, challenges overcome, and lessons learned

We encountered a couple of key challenges. First, Riley had difficulty running the test suites when pulling from GitHub. For some reason, the way the project was set up did not work on his device, but it worked on Yousefs. Since this happened at the end, it did not affect Riley too much. Yousef would just re-run the tests on his device to get results for the tests for the lab report. Another challenge was figuring out how many tests we needed for each function. We knew it was key to utilize equivalence partitioning and boundary analysis. However, we believed it was better to use both of the methods and also test for specific cases. This experience helped us to think critically about SUT designs and how to delegate the workload better. 

# 6 Comments/feedback on the lab itself
We felt that the lab was pretty easy to follow. It was effective practice for black box testing strategies, overall a good experience. 
